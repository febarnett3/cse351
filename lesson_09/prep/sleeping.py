"""
This example was generated by Google Gemini
"""

import threading
import time
import random

# --- Configuration ---
NUM_WAITING_CHAIRS = 3      # Number of chairs in the waiting room
CUT_TIME_MIN = 1            # Minimum time (seconds) for a haircut
CUT_TIME_MAX = 3            # Maximum time (seconds) for a haircut
CUSTOMER_ARRIVAL_MIN = 0.2  # Minimum time (seconds) between customer arrivals
CUSTOMER_ARRIVAL_MAX = 1.5  # Maximum time (seconds) between customer arrivals
SIMULATION_DURATION = 15    # Total simulation time (seconds)

# --- Synchronization Primitives ---
# Mutex to protect access to the waiting_chairs_occupied count
access_seats = threading.Lock()

# Semaphore representing customers ready for a haircut (waiting or in barber chair)
# Barber waits on this.
customer_ready = threading.Semaphore(0)

# Semaphore representing the barber being ready to cut hair.
# Customer waits on this after signaling customer_ready.
barber_ready = threading.Semaphore(0)

# --- Shared State ---
waiting_chairs_occupied = 0

# --- Event to signal simulation end ---
stop_event = threading.Event()

# --- Barber Thread ---
def barber_thread():
    """The barber's routine."""
    print("Barber: Opening the shop.")
    while not stop_event.is_set():
        print("Barber: Sleeping... zzz")
        # Wait for a customer to arrive and signal they are ready.
        # This blocks if the semaphore count is 0 (no customers waiting/ready).
        customer_ready.acquire()

        # Check if woken up to terminate simulation
        if stop_event.is_set():
            break

        # --- A customer has arrived and woken the barber ---
        print("Barber: Woke up! A customer is ready.")

        # Signal that the barber is now ready to cut hair.
        # The waiting customer will acquire this.
        barber_ready.release()

        # Cut hair (simulate time)
        cut_duration = random.uniform(CUT_TIME_MIN, CUT_TIME_MAX)
        print(f"Barber: Cutting hair for {cut_duration:.2f} seconds...")
        time.sleep(cut_duration)
        print("Barber: Finished cutting hair.")

    print("Barber: Closing shop.")

# --- Customer Thread ---
def customer_thread(customer_id):
    """A customer's routine: arrive, wait if necessary, get haircut, leave."""
    global waiting_chairs_occupied
    print(f"Customer {customer_id}: Arriving at the shop.")

    # Acquire mutex to check/modify waiting chair count atomically
    access_seats.acquire()
    if waiting_chairs_occupied < NUM_WAITING_CHAIRS:
        # There is space in the waiting room
        waiting_chairs_occupied += 1
        print(f"Customer {customer_id}: Sitting in waiting chair. ({waiting_chairs_occupied}/{NUM_WAITING_CHAIRS} occupied)")

        # Release the mutex BEFORE signaling and potentially waiting
        access_seats.release()

        # Signal that a customer is ready (wake up barber if sleeping,
        # or increments count for barber to process next).
        customer_ready.release()

        # Wait for the barber to signal that they are ready for *this* customer.
        # This blocks until the barber calls barber_ready.release().
        barber_ready.acquire()

        # --- Getting haircut ---
        print(f"Customer {customer_id}: Getting haircut.")
        # (Customer thread conceptually blocks here while barber 'cuts hair')

        # --- Haircut finished (implied when barber finishes 'cut hair' sleep) ---
        print(f"Customer {customer_id}: Haircut finished, leaving.")

    else:
        # No waiting chairs available, customer leaves (balks)
        print(f"Customer {customer_id}: Shop is full ({waiting_chairs_occupied}/{NUM_WAITING_CHAIRS} occupied), leaving!")
        # Release the mutex
        access_seats.release()

# --- Main Simulation Logic ---
if __name__ == "__main__":
    customer_count = 0
    customer_threads = []

    print("--- Barber Shop Simulation Starting ---")
    print(f"Waiting chairs: {NUM_WAITING_CHAIRS}")

    # Start the barber thread
    barber = threading.Thread(target=barber_thread, name="Barber")
    barber.start()

    # Start generating customers
    start_time = time.time()
    while time.time() - start_time < SIMULATION_DURATION:
        # Wait for a random time before the next customer arrives
        time.sleep(random.uniform(CUSTOMER_ARRIVAL_MIN, CUSTOMER_ARRIVAL_MAX))
        customer_count += 1
        customer = threading.Thread(target=customer_thread, args=(customer_count,), name=f"Cust-{customer_count}")
        customer_threads.append(customer)
        customer.start()

    print(f"\n--- Simulation time ({SIMULATION_DURATION}s) elapsed. No more new customers. ---")
    stop_event.set() # Signal threads to stop gracefully

    # Ensure the barber wakes up one last time to check the stop_event
    customer_ready.release()

    # Wait for the barber thread to finish
    barber.join()

    # Wait for any remaining customer threads to complete their interaction
    print("--- Waiting for remaining customers to finish... ---")
    for t in customer_threads:
        t.join()

    print("--- Barber Shop Simulation Finished ---")
